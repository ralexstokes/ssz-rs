//! This file was generated by `ssz-rs-test-gen`; do NOT manually edit.
mod test_utils;

use ssz_rs::prelude::*;
use test_utils::{
    deserialize, hash_tree_root, read_ssz_snappy_from_test_data, root_from_hex, serialize,
};

#[test]
#[should_panic]
fn test_bitvector_bitvec_0() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_0/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<0>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_16_max() {
    let mut value = Bitvector::<16>::try_from(Vec::<u8>::from_iter([255, 255]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_16_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<16> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xffff000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_16_max_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_16_max_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<16>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_16_random() {
    let mut value = Bitvector::<16>::try_from(Vec::<u8>::from_iter([46, 236]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_16_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<16> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x2eec000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_16_random_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_16_random_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<16>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_16_zero() {
    let mut value = Bitvector::<16>::try_from(Vec::<u8>::from_iter([0, 0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_16_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<16> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_16_zero_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_16_zero_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<16>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_1_max() {
    let mut value = Bitvector::<1>::try_from(Vec::<u8>::from_iter([1]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_1_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<1> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0100000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_1_max_2() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_1_max_2/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<1>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_1_random() {
    let mut value = Bitvector::<1>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_1_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<1> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_1_random_2() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_1_random_2/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<1>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_1_zero() {
    let mut value = Bitvector::<1>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_1_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<1> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_1_zero_2() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_1_zero_2/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<1>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_2_max() {
    let mut value = Bitvector::<2>::try_from(Vec::<u8>::from_iter([3]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_2_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<2> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0300000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_2_max_3() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_2_max_3/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<2>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_2_random() {
    let mut value = Bitvector::<2>::try_from(Vec::<u8>::from_iter([3]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_2_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<2> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0300000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_2_random_3() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_2_random_3/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<2>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_2_zero() {
    let mut value = Bitvector::<2>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_2_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<2> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_2_zero_3() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_2_zero_3/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<2>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_31_max() {
    let mut value =
        Bitvector::<31>::try_from(Vec::<u8>::from_iter([255, 255, 255, 127]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_31_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<31> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xffffff7f00000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
fn test_bitvector_bitvec_31_random() {
    let mut value =
        Bitvector::<31>::try_from(Vec::<u8>::from_iter([114, 223, 100, 21]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_31_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<31> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x72df641500000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
fn test_bitvector_bitvec_31_zero() {
    let mut value = Bitvector::<31>::try_from(Vec::<u8>::from_iter([0, 0, 0, 0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_31_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<31> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_32_max_33() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_32_max_33/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<32>>(&encoding);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_32_random_33() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_32_random_33/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<32>>(&encoding);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_32_zero_33() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_32_zero_33/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<32>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_3_max() {
    let mut value = Bitvector::<3>::try_from(Vec::<u8>::from_iter([7]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_3_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<3> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0700000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_3_max_4() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_3_max_4/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<3>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_3_random() {
    let mut value = Bitvector::<3>::try_from(Vec::<u8>::from_iter([7]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_3_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<3> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0700000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_3_random_4() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_3_random_4/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<3>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_3_zero() {
    let mut value = Bitvector::<3>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_3_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<3> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_3_zero_4() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_3_zero_4/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<3>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_4_max() {
    let mut value = Bitvector::<4>::try_from(Vec::<u8>::from_iter([15]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_4_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<4> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0f00000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_4_max_5() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_4_max_5/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<4>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_4_random() {
    let mut value = Bitvector::<4>::try_from(Vec::<u8>::from_iter([13]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_4_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<4> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0d00000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_4_random_5() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_4_random_5/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<4>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_4_zero() {
    let mut value = Bitvector::<4>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_4_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<4> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_4_zero_5() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_4_zero_5/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<4>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_512_max() {
    let mut value = Bitvector::<512>::try_from(
        Vec::<u8>::from_iter([
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_512_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<512> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x8667e718294e9e0df1d30600ba3eeb201f764aad2dad72748643e4a285e1d1f7");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_512_max_513() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_512_max_513/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<512>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_512_random() {
    let mut value = Bitvector::<512>::try_from(
        Vec::<u8>::from_iter([
            80, 152, 209, 178, 29, 181, 106, 197, 239, 143, 96, 144, 164, 12, 18, 211, 12, 52, 56,
            123, 68, 155, 79, 101, 99, 209, 248, 11, 40, 23, 218, 4, 52, 27, 132, 94, 218, 129,
            196, 1, 104, 151, 30, 209, 179, 4, 107, 245, 244, 12, 98, 101, 186, 91, 77, 43, 37,
            167, 152, 212, 26, 235, 70, 222,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_512_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<512> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xfbdb71e991457c4fd956e16be1ae1dc959bceaf00f692fec9431de3f0175655a");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_512_random_513() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_512_random_513/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<512>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_512_zero() {
    let mut value = Bitvector::<512>::try_from(
        Vec::<u8>::from_iter([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_512_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<512> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xf5a5fd42d16a20302798ef6ed309979b43003d2320d9f0e8ea9831a92759fb4b");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_512_zero_513() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_512_zero_513/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<512>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_513_max() {
    let mut value = Bitvector::<513>::try_from(
        Vec::<u8>::from_iter([
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_513_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<513> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x222dd9eebc6467de9788eb1c05ce9c2da8ecc89abdd38810925ce061d91236ef");
    assert_eq!(root, expected_root);
}

#[test]
fn test_bitvector_bitvec_513_random() {
    let mut value = Bitvector::<513>::try_from(
        Vec::<u8>::from_iter([
            35, 7, 207, 77, 114, 9, 148, 22, 93, 128, 20, 64, 206, 32, 22, 204, 234, 200, 252, 243,
            1, 27, 216, 80, 138, 122, 252, 100, 16, 87, 153, 189, 121, 111, 50, 2, 193, 3, 227, 15,
            13, 117, 201, 41, 104, 97, 61, 253, 57, 156, 134, 135, 194, 28, 100, 62, 189, 36, 213,
            231, 15, 225, 31, 196, 0,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_513_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<513> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x84f06e5024cc71b8162c3a96f4b743505481722da5a281a6aaa69791b9f79283");
    assert_eq!(root, expected_root);
}

#[test]
fn test_bitvector_bitvec_513_zero() {
    let mut value = Bitvector::<513>::try_from(
        Vec::<u8>::from_iter([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ])
        .as_ref(),
    )
    .unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_513_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<513> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xdb56114e00fdd4c1f85c892bf35ac9a89289aaecb1ebd0a96cde606a748b5d71");
    assert_eq!(root, expected_root);
}

#[test]
fn test_bitvector_bitvec_5_max() {
    let mut value = Bitvector::<5>::try_from(Vec::<u8>::from_iter([31]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_5_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<5> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x1f00000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_5_max_6() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_5_max_6/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<5>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_5_random() {
    let mut value = Bitvector::<5>::try_from(Vec::<u8>::from_iter([3]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_5_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<5> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0300000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_5_random_6() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_5_random_6/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<5>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_5_zero() {
    let mut value = Bitvector::<5>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_5_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<5> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_5_zero_6() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_5_zero_6/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<5>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_8_max() {
    let mut value = Bitvector::<8>::try_from(Vec::<u8>::from_iter([255]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_8_max/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<8> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xff00000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_8_max_9() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_8_max_9/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<8>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_8_random() {
    let mut value = Bitvector::<8>::try_from(Vec::<u8>::from_iter([223]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_8_random/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<8> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0xdf00000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_8_random_9() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_8_random_9/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<8>>(&encoding);
}

#[test]
fn test_bitvector_bitvec_8_zero() {
    let mut value = Bitvector::<8>::try_from(Vec::<u8>::from_iter([0]).as_ref()).unwrap();
    let encoding = serialize(&value);
    let expected_encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/valid/bitvec_8_zero/serialized.ssz_snappy",
    );
    assert_eq!(encoding, expected_encoding);

    let recovered_value: Bitvector<8> = deserialize(&expected_encoding);
    assert_eq!(recovered_value, value);

    let root = hash_tree_root(&mut value);
    let expected_root =
        root_from_hex("0x0000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(root, expected_root);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_8_zero_9() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_8_zero_9/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<8>>(&encoding);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_9_max_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_9_max_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<9>>(&encoding);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_9_random_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_9_random_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<9>>(&encoding);
}

#[test]
#[should_panic]
fn test_bitvector_bitvec_9_zero_8() {
    let encoding = read_ssz_snappy_from_test_data(
        "ssz-rs/tests/data/bitvector/invalid/bitvec_9_zero_8/serialized.ssz_snappy",
    );

    deserialize::<Bitvector<9>>(&encoding);
}
